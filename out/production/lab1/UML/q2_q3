// 
Q2

Open/Closed Principle

+ Vehicle- hierarkin följer OCP:
man kan lägga till nya fordonstyper utan att ändra Vehicle eller andra bilklasser.
CarController använder instanceof Volvo240 för att avgöra om bilen får lastas.
Detta är ett mindre OCP-brott, men acceptabelt eftersom verkstaden är specialiserad.
Förbättring:
Man skulle kunna införa ett interface som Loadable eller WorkshopEligible.

-------------------------------------------------------------------------------

Interface Segregation Principle
+ Movable är ett bra, litet interface som följer ISP.
- Det finns implicit funktionalitet (turbo, flak, lastning) som hade kunnat brytas ut i egna interfaces:
- TurboCar
- TruckBed
- Loadable
Det hade minskat behovet av specialfall och gjort controller ännu renare.

-------------------------------------------------------------------------------


High Cohesion / Low Coupling
Cohesion
Hög cohesion:
- Vehicle / Car / Truck / Saab95 / Volvo240 / Scania
→ modellerar fordon och deras beteenden
- Workshop<T>
→ lagrar bilar
- DrawPanel
→ renderar fordon
- CarView
→ UI-hantering
Låg cohesion:
- CarController
→ hanterar timer, UI-koppling, fordonsuppdatering, väggkollision, workshop-logik, turbo, flak, lastning
→ gör för mycket, bryter SRP
Förbättring:
Flytta ut väggkollision, workshop-logik och specialbeteenden till egna serviceklasser.


Coupling
+ Generellt låg coupling mellan model och view/controller.
- DrawPanel är beroende av konkreta biltyper för att välja bild.
Det är ett DIP/OCP-brott.
- CarView och CarController har stark koppling: dubbelsidig kompositionspil 
- Controller skapar view
- View håller en referens tillbaka till controller
Detta är tight coupling och bryter SoC och DIP.
Förbättring:
Inför ett interface som CarView kan bero på, t.ex. ICarController.

-------------------------------------------------------------------------------

Dependency Inversion Principle
+ Vehicle → Movable följer DIP.
+ Workshop<T> använder generics och beror på abstraktioner.
- DrawPanel beror på konkreta biltyper (Volvo240, Saab95, Scania).
- CarController beror fortfarande på CarView (konkret klass).
- Workshop-logiken är beroende av Volvo240.
-------------------------------------------------------------------------------

Single Responsibility Principle
+ De flesta klasser följer SRP:
Vehicle, Car, Truck, Saab95, Volvo240, Scania, Workshop, DrawPanel, CarView.
- CarController bryter mot SRP:
den har många separata ansvarsområden och många orsaker att förändras.
Förbättring:
Dela upp CarController i mindre komponenter:
- CollisionHandler
- WorkshopService
- TurboService
- TruckBedService
- VehicleUpdateService




Q3

• Vehicle / Car / Truck / Saab95 / Volvo240 / Scania
Ansvar:
Representerar olika fordonstyper och deras beteenden (rörelse, gas/broms, riktning, specialfunktioner).
Har hög cohesion och följer SoC och SRP.
Anledning till förändring:
Om fordonets beteende ändras, nya regler införs eller nya attribut behövs (t.ex. vikt, acceleration).

• Workshop
Ansvar:
Hantera verkstadens kapacitet och lagra bilar av en viss typ.
Anledning till förändring:
Om lastningsregler ändras eller kapacitetshanteringen behöver justeras.

• DrawPanel
Ansvar:
Renderar fordon och hämtar rätt bild för varje biltyp.
Anledning till förändring:
Nya biltyper kräver nya bilder. Klassen är känslig för nya biltyper eftersom den är beroende av konkreta klasser, vilket bryter lite mot DIP/OCP.

• CarView
Ansvar:
Hanterar UI-komponenter (knappar, paneler, spinner) och skickar användarinput till controller.
Anledning till förändring:
Nya knappar, ändrad layout eller ändrade UI-krav.
Har stark koppling till CarController.

• CarController
Ansvar:
Hanterar timer-loop, uppdaterar bilar, väggkollision, workshop-logik, knapplogik och specialbeteenden via Vehicle.Action.
Anledning till förändring:
Många — eftersom klassen gör mycket. Exempel: ändrade kollisionregler, ändrad workshop-logik, nya UI-krav eller nya specialbeteenden.
Bedömning:
Låg cohesion och bryter SRP.
Bör dekomponeras i mindre delar (t.ex. CollisionHandler, WorkshopService, TurboService, TruckBedService).

• Dekomposition
Den enda klassen som tydligt behöver delas upp är CarController, eftersom den har många separata ansvarsområden.
Genom att flytta ut kollisioner, workshop-logik och specialbeteenden till egna serviceklasser skulle den följa SRP och SoC betydligt bättre.


Q4

Uppdelning av CarController i Service klasser:
Klassen har just nu för många ansvarsområden. Genom att dela upp den i mindre klasser löser vi problemet som vi hade med SRP. Den stora klassen har nu blivit 5 mindre klasser, som alla följer SRP. Detta är även bättre för att motverka problemet med cohesion, då dessa klasser egentligen inte har så mycket gemensamt, även om man skulle kunna tro det. Dessutom löser detta problemet med att det fanns för många områden som vi skulle kunna förändra i framtiden. Det blir nu även lättare att förstå koden snabbt, testa varje delbeteende självt samt göra det lättare med code-reuse.

Ny ICarController Interface:
Förut var CarView och CarController hårt kopplade åt båda håll. Detta bröt mot DIP då visualiseringen berodde direkt på en konkret implementation.

Utbrytning av specialfunktioner i egna interfaces:
Vi har nu lagt till TurboCar för fordon med turbo, TruckBed för fordon med flak, Loadable för fordon som får lastas på billastare, samt WorkshopEligable för att lättare kunna kontrollera vilka fordon som får vara i vilken verkstad. Klasserna behöver nu bara implementera det de faktiskt stödjer, och ingen tvingas ha saker den inte behöver, vilket är bättre för ISP. Denna lösning är också direkt bättre för OCP då vi lätt kan lägga till t.ex en ny bil med turbo. De uppdelade klasserna i CarController kan nu också arbeta mot interfaces istället för konkreta klasser.

Flytta ut hårkodat Volvo240 från CarController:
Innan hade vi en instanceOf i CarController, vilket nu har bytts ut mot interfacet WorkshopEligible. Detta följer OCP bättre då vi inte behöver lägga till en ny instanceOf om vi vill lägga till en ny bil som kan komma in i en workshop.

DrawPanel:
DrawPanel var tidigare beroende av konkreta biltyper för att välja bild, vilket bröt mot DIP och OCP. Vi lägger därför till Drawable som är ett interface som fordonen implementerar, och DrawPanel beror nu på denna istället för konkreta klasser. Vi kan nu lättare lägga till nya fordon utan att ändra i DrawPanel. Alternativt skulle man kunna låta en klass som Vehicle eller Car implementera interfaces, men då måste man vara säker på att det finns bilder till alla objekt som är subtyp till dessa.

Sammanfattat:
SRP/SoC: Färre ansvar per klass, och färre skäl att ändra saker o ting. Detta gör allt lättare att underhålla och förstå.
DIP: CarView beror nu på abstraktionen ICarController istället för CarController, alltså mindre beroende av en implementation. DrawPanel beror nu på ett generellt Drawable-interface istället för konkreta bilklasser, vilket minskar beroendet på specifika fordonstyper.
ISP: Nya små interfaces, som gör att objekt inte behöver ha funktionalitet de inte behöver.
OCP: Det går nu lättare att lägga till nya fordonstyper, vilket ger mer extensibility. Nya fordon kan även visualiseras utan att ändra DrawPanel, eftersom funktionaliteten inte längre är hårdkopplad till specifika bilklasser.
Cohesion/Coupling: Varje del gör en sak och känner till färre andra delar, vilket gör systemet mer stabilt för förändringar i framtiden.




Refraktorisering:
Skapa ICarController Interfacet och låt CarController implementera det. Ändra sedan CarView så att den refererar till det nya interfacet.
Lägg till interfacet Drawable för visualisering. Låt fordonen själva implementera interfacet och flytta bildvalet till fordonet. Ändra även DrawPanel så att den använder interfacet istället för en massa “if”.
Inför de nya, små, interfacen för specialfunktionaliteterna. Alltså: TurboCar, TruckBed, Loadable, WorkshopEligible. Låt sedan relevanta fordon implementera dem. (Saab - TurboCar, Volvo - WorkshopEligible, Scania - TruckBed, lastbara fordon - Loadable)
Skapa serviceklasserna och koppla in dessa i CarController. Alltså: VehicleUpdateService, CollisionHandler, WorkshopService, TurboService, TruckBedService. Lägg in dessa som fält i CarController.
Flytta sedan över lämplig funktionalitet från CarController in i lämplig ny serviceklass.
Låt de nya Serviceklasserna arbeta mot de mindre interfacen för specialfunktionalitet
Koppla billastaren till loadable, istället för att bero på hårdkodade värden.
Säkerställ att CarController nu bara beter sig som en orkestratör och att all annan funktionalitet är utflyttad.
Kör test på de nya ändringarna, och testa så visualiseringen fortfarande funkar som förväntat.

Uppdelning av arbete som går att arbeta på parallellt:

Område 1:
Skapa ICarController och sätt CarView till att bero på detta.
Inför Drawable och uppdatera DrawPanel att bero på denna istället för

Område 2:
Skapa de mindre interfacen för specialfunktionalitet och låta relevant fordon implementera rätt interface. (TurboCar, TruckBed, Loadable, WorkshopEligible)

Område 3:
Skapa de nya serviceklasserna och flytta ut funktionaliteten från CarController in i dessa.

Resterande bygger på att dessa är klara.


//